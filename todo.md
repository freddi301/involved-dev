# TODO

- from books (code complete, clean code, implementation patterns, ddd, analysis patterns, design patterns)
- checklist project wide
- checklist feature wide
- process
- principles
  - kiss
  - [YAGNI](https://en.wikipedia.org/wiki/You_aren%27t_gonna_need_it)
  - composition over inheritance
  - big ball of mud
  - no abstraction is better than bad abstraction
  - guard code aganst future changes
  - refactor boundaries
  - low coupling high coesion
  - information locality
  - open close
  - solid
  - twelve factor apps
  - DRY
  - WET
  - SRP
  - open closed
  - AHA (avaoid hasty abstractions)
  - worse is better
  - If it ain’t broke, don’t fix it
  - dependency inversion
  - LSP (liskov)
  - ISP (interface segregation)
  - same abstraction level per method
  - avoid premature optimization
  - no clever code
  - code colocality
  - code readability
  - code navigability
- patterns
  - singleton
  - decorator
  - observer
  - chain of responsability
  - party
  - mux-demux
  - piggyback
  - middleware
  - specification
  - predicate
  - command
  - recursion schemes
  - lenses
  - coroutines
  - eventloop
  - multi-threading
  - promise/future
  - observable
  - stream
  - pattern matching
  - interpreter
  - effects
  - cps
  - actors
  - denpendency injection
  - delegate
  - mixin
  - proxy
  - mediator
  - factory
  - ui component
  - thunk
  - clojure
  - explicit clojure
  - feature flag
  - template method
  - currying
  - named parameters
  - callback
  - facade
  - query language (rest, graphql, linq)
  - remote facade (must not be fine grained)
  - final tagless
  - builder
  - lazy
  - object pool
  - prototype
  - RAII (resource acquisition is initialization)
  - lifecycles
  - adapter
  - bridge
  - composite
  - structural sharing
  - marker/phantom type
  - module/ modeule pattern
  - special case object (zero or default)
  - iterator
  - memento
  - serialization
  - strategy
  - visitor
  - batch
  - template
  - dsl
  - mv(h)c(sr) (mode-view-controller-service-repository)
  - value object
  - entity
  - lazy loading
  - sum of prioducts (aka haskell data type)
  - composite
  - cache LRU/TTL/Weak
  - garbage collection
  - set
  - map/flatMap/compose/lift/identity/group/sort/
  - transaction
  - transaction script
  - pure functions
  - table module
  - domain model
  - service layer
  - table data gateway
  - row data gateway
  - active record
  - data mapper
  - dto
  - dao
  - unit of work
  - identity map
  - metadata mapping
  - query object
  - pessimistic lock
  - optimistic lock
  - crdt
  - layer supertype
  - socket
  - session
  - token
  - layer supertype
- data structures
  - monad, io, state, free
  - comonad
  - trasversable
  - list, linked, double-linked, array-list
  - queue
  - heap
  - functor
  - monoid
  - map, hash map
  - trie
  - tree, binary tree, multitree, prefix tree
  - immutable data structures
  - realtime data structures
  - worst case data structures
  - ammortized data structures
  - applicative
  - catamorphism
  - anamorphism
  - merkle tree
  - dag
  - graph
- refactoring principles
  - booleans should be enums
  - one function/variable per functionality, one function must do at most one thing, but can delegate n operations
  - good naming, name must capture sinthetically what function does, if it containt and/or/with/without that means it does more than one thing
  - factor out flags
  - naming: pronunceable, searchable, ubiquitous, unambigous
  - use callbacks as parameters when uncertain for use
  - delete commented/unused code
  - structure code that is friendly for IDE and tools and static analisis
  - use debugger efficiently
  - write unit tests for business logic
  - write integration tests
  - do not test third party code
  - use versioning tools
  - look at code coverage (100% coverage doesn't mean every result is tested)
  - use automatic formatting tools (tweak for better diffs)
  - write code that is easy to delete
  - write comments only if code can't expplain itself for performance reasons
  - wrap collections
- quotes
  - any problem can be solved with a level of indirection, except too many levels of indirection
  - hard things are naming and cache invalidation
- checklist commit wide
- about collaboration
- about development process
- automated assist tools
- version control (git)
  - about branching
  - about commit
  - git best practices
- integrate with other tools, ides, precommit-hooks and so
- react development workflow
- divide and conquer with pseudocode
- abstract over constants
- progressive refactor with tools
